//==============================================================================
// This software is part of the Open Standard for Unattended Sensors (OSUS)
// reference implementation (OSUS-R).
//
// To the extent possible under law, the author(s) have dedicated all copyright
// and related and neighboring rights to this software to the public domain
// worldwide. This software is distributed without any warranty.
//
// You should have received a copy of the CC0 Public Domain Dedication along
// with this software. If not, see
// <http://creativecommons.org/publicdomain/zero/1.0/>.
//==============================================================================
package mil.dod.th.ose.remote.observation;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.List;

import aQute.bnd.annotation.component.Activate;
import aQute.bnd.annotation.component.Component;
import aQute.bnd.annotation.component.Deactivate;
import aQute.bnd.annotation.component.Reference;

import com.google.protobuf.InvalidProtocolBufferException;
import com.google.protobuf.Message;

import mil.dod.th.core.log.LoggingService;
import mil.dod.th.core.observation.types.Observation;
import mil.dod.th.core.persistence.ObservationQuery;
import mil.dod.th.core.persistence.ObservationStore;
import mil.dod.th.core.remote.RemoteChannel;
import mil.dod.th.core.remote.messaging.MessageFactory;
import mil.dod.th.core.remote.objectconverter.JaxbProtoObjectConverter;
import mil.dod.th.core.remote.objectconverter.ObjectConverterException;
import mil.dod.th.core.remote.proto.ObservationStoreMessages.FindObservationByUUIDRequestData;
import mil.dod.th.core.remote.proto.ObservationStoreMessages.FindObservationByUUIDResponseData;
import mil.dod.th.core.remote.proto.ObservationStoreMessages.GetObservationCountRequestData;
import mil.dod.th.core.remote.proto.ObservationStoreMessages.GetObservationCountResponseData;
import mil.dod.th.core.remote.proto.ObservationStoreMessages.GetObservationRequestData;
import mil.dod.th.core.remote.proto.ObservationStoreMessages.GetObservationResponseData;
import mil.dod.th.core.remote.proto.ObservationStoreMessages.ObservationStoreNamespace;
import mil.dod.th.core.remote.proto.ObservationStoreMessages.ObservationStoreNamespace.ObservationStoreMessageType;
import mil.dod.th.core.remote.proto.ObservationStoreMessages.Query;
import mil.dod.th.core.remote.proto.ObservationStoreMessages.Range;
import mil.dod.th.core.remote.proto.ObservationStoreMessages.RemoveObservationByUUIDRequestData;
import mil.dod.th.core.remote.proto.ObservationStoreMessages.RemoveObservationRequestData;
import mil.dod.th.core.remote.proto.ObservationStoreMessages.RemoveObservationResponseData;
import mil.dod.th.core.remote.proto.ObservationStoreMessages.TimeConstraintData;
import mil.dod.th.core.remote.proto.RemoteBase.Namespace;
import mil.dod.th.core.remote.proto.RemoteBase.TerraHarvestMessage;
import mil.dod.th.core.remote.proto.RemoteBase.TerraHarvestPayload;
import mil.dod.th.core.remote.proto.SharedMessages.UUID;
import mil.dod.th.core.types.observation.ObservationSubTypeEnum;
import mil.dod.th.ose.remote.MessageRouterInternal;
import mil.dod.th.ose.remote.MessageService;
import mil.dod.th.ose.remote.api.EnumConverter;
import mil.dod.th.ose.remote.util.RemoteInterfaceUtilities;
import mil.dod.th.ose.shared.SharedMessageUtils;
import mil.dod.th.remote.converter.ObservationSubTypeEnumConverter;
import mil.dod.th.remote.lexicon.observation.types.ObservationGen;
import mil.dod.th.remote.lexicon.types.observation.ObservationTypesGen.ObservationSubType;
import mil.dod.th.remote.lexicon.types.remote.RemoteTypesGen;

import org.osgi.service.event.Event;
import org.osgi.service.event.EventAdmin;

/**
 * This component assists with accessing the {@link ObservationStore} from remote systems. 
 * @author callen
 *
 */
//service is not provided as this would create a cycle, instead this class registers with the message router
@Component(immediate = true, provide = { }) //NOCHECKSTYLE: High class fan out. Need to process all possible observation
public class ObservationMessageService implements MessageService //store messages
{
    /**
     * Observation store service that persistently stores observations.
     */
    private ObservationStore m_ObservationStore;

    /**
     * Service for creating messages to send through the remote interface.
     */
    private MessageFactory m_MessageFactory;

    /**
     * Service to use for posting events generated by this service.
     */
    private EventAdmin m_EventAdmin;

    /**
     * Service that assists in converting instances of {@link Observation}s from 
     * JAXB objects to proto messages.
     */
    private JaxbProtoObjectConverter m_Converter;

    /**
     * {@link LoggingService} logging service.
     */
    private LoggingService m_Logging;

    /**
     * Routes incoming messages.
     */
    private MessageRouterInternal m_MessageRouter;

    /**
     * Bind the {@link EventAdmin} service.
     * 
     * @param eventAdmin
     *      event admin service used to post events
     */
    @Reference
    public void setEventAdmin(final EventAdmin eventAdmin)
    {
        m_EventAdmin = eventAdmin;
    }

    /**
     * Bind a message router to register.
     * 
     * @param messageRouter
     *      router that handles incoming messages
     */
    @Reference
    public void setMessageRouter(final MessageRouterInternal messageRouter)
    {
        m_MessageRouter = messageRouter;
    }

    /**
     * Bind to the service for creating remote messages.
     * 
     * @param messageFactory
     *      service that create messages
     */
    @Reference
    public void setMessageFactory(final MessageFactory messageFactory)
    {
        m_MessageFactory = messageFactory;
    }

    /**
     * Observation store service used to manage observations.
     * 
     * @param observationStore
     *     the observation store service
     */
    @Reference
    public void setObservationStore(final ObservationStore observationStore)
    {
        m_ObservationStore = observationStore;
    }

    /**
     * Set the {@link mil.dod.th.core.remote.objectconverter.JaxbProtoObjectConverter}.
     * 
     * @param converter
     *     the service responsible for converting between proto and JAXB objects.
     */
    @Reference
    public void setJaxbProtoObjectConverter(final JaxbProtoObjectConverter converter)
    {
        m_Converter = converter;        
    }
    
    /**
     * Binds the logging service for logging messages.
     * 
     * @param logging
     *            Logging service object
     */
    @Reference
    public void setLoggingService(final LoggingService logging)
    {
        m_Logging = logging;
    }

    /**
     * Activate method to bind this service to the message router. Also creates an object converter for observations.
     */
    @Activate
    public void activate()
    {
        m_MessageRouter.bindMessageService(this);
    }
    
    /**
     * Deactivate component by unbinding the service from the message router.
     */
    @Deactivate
    public void deactivate()
    {
        m_MessageRouter.unbindMessageService(this);
    }

    @Override
    public Namespace getNamespace() 
    {
        return Namespace.ObservationStore;
    }

    @Override
    public void handleMessage(final TerraHarvestMessage message, final TerraHarvestPayload payload,
        final RemoteChannel channel) throws IOException 
    {
        final ObservationStoreNamespace obsMessage = ObservationStoreNamespace.parseFrom(payload.getNamespaceMessage());
        final Message dataMessage;
     
        // message specific handling
        switch (obsMessage.getType())
        {
            case GetObservationRequest:
                dataMessage = getObservationsByQuery(message, obsMessage, channel);
                break;
            case GetObservationResponse:
                dataMessage = GetObservationResponseData.parseFrom(obsMessage.getData());
                break;
            case RemoveObservationRequest:
                dataMessage = removeObservation(message, obsMessage, channel);
                break;
            case RemoveObservationResponse:
                dataMessage = RemoveObservationResponseData.parseFrom(obsMessage.getData());
                break;
            case RemoveObservationByUUIDRequest:
                dataMessage = removeObservationByUUID(message, obsMessage, channel);
                break;
            case RemoveObservationByUUIDResponse:
                dataMessage = null;
                break;
            case FindObservationByUUIDRequest:
                dataMessage = findObservation(message, obsMessage, channel);
                break;
            case FindObservationByUUIDResponse:
                dataMessage = FindObservationByUUIDResponseData.parseFrom(obsMessage.getData());
                break;
            case GetObservationCountRequest:
                dataMessage = getObservationByCountQuery(message, obsMessage, channel);
                break;
            case GetObservationCountResponse:
                dataMessage = GetObservationCountResponseData.parseFrom(obsMessage.getData());
                break;
            default:
                throw new UnsupportedOperationException(
                        String.format("Message type: %s is not a supported type for"
                                + " the ObservationMessageService namespace.", obsMessage.getType()));
        }

        // post event that an ObservationStore message was received
        final Event event = RemoteInterfaceUtilities.createMessageReceivedEvent(message, payload, obsMessage, 
            obsMessage.getType(), dataMessage, channel);
        m_EventAdmin.postEvent(event); 
    }
    
    /**
     * Handle the GetObservationCountRequest message.
     * @param message
     *  message that contains the request parameters to use to retrieve the total count of observations that
     *  match the given query
     * @param obsMessage
     *  message containing the observation store namespace message
     * @param channel
     *  the channel from which the message originated from
     * @return
     *  the parsed data message
     * @throws InvalidProtocolBufferException
     *  throw in the event that the namespace specific message could not be parsed
     */
    private Message getObservationByCountQuery(final TerraHarvestMessage message, 
            final ObservationStoreNamespace obsMessage, 
            final RemoteChannel channel) throws InvalidProtocolBufferException
    {
        final GetObservationCountRequestData request = GetObservationCountRequestData.parseFrom(obsMessage.getData());
        
        final ObservationQuery obsQuery = createObservationQuery(request.getObsQuery());
        
        final GetObservationCountResponseData response = GetObservationCountResponseData
                .newBuilder().setCount(obsQuery.getCount()).build();
        
        //send the response
        m_MessageFactory.createObservationStoreResponseMessage(message, 
                ObservationStoreMessageType.GetObservationCountResponse, response).queue(channel);
        
        //return the request message for event
        return request;
    }

    /**
     * Handle the GetObservationRequest message. 
     * @param message
     *     message that contains the request parameters to use to query that observation store
     * @param obsMessage
     *     message containing the observation store namespace message
     * @param channel
     *     the channel from which the message originated from
     * @return
     *     the parsed data message
     * @throws InvalidProtocolBufferException 
     *     throw in the event that the namespace specific message could not be parsed
     */
    private Message getObservationsByQuery(final TerraHarvestMessage message, 
        final ObservationStoreNamespace obsMessage, final RemoteChannel channel) throws InvalidProtocolBufferException
    {
        //parse the get observation request
        final GetObservationRequestData request = GetObservationRequestData.parseFrom(obsMessage.getData());
        if (request.getObservationFormat() != RemoteTypesGen.LexiconFormat.Enum.NATIVE)
        {
            throw new UnsupportedOperationException(
                 String.format("Lexicon format %s is not valid for observation query", request.getObservationFormat()));
        }
        
        //collection of observations
        final ObservationQuery obsQuery = createObservationQuery(request.getObsQuery());
        final Collection<Observation> observations = obsQuery.execute();
        
        //get a converted list of observations returned
        final List<ObservationGen.Observation> observationConv = createProtoObservationList(observations);
        
        //response message
        final GetObservationResponseData response = GetObservationResponseData.newBuilder().
            addAllObservationNative(observationConv).build();

        //send response
        m_MessageFactory.createObservationStoreResponseMessage(message, 
            ObservationStoreMessageType.GetObservationResponse, response).queue(channel);
        
        //return the request message for event
        return request;
    }
    
    /**
     * Handle the request to remove observations by an {@link Query} type. 
     * @param message
     *     message that contains the request parameters to use to query the observation store
     * @param obsMessage
     *     message containing the observation store namespace message
     * @param channel
     *     the channel from which the message originated from
     * @return
     *     the parsed data message
     * @throws InvalidProtocolBufferException 
     *     throw in the event that the namespace specific message could not be parsed.
     */
    private Message removeObservation(final TerraHarvestMessage message, final ObservationStoreNamespace obsMessage, 
        final RemoteChannel channel) throws InvalidProtocolBufferException 
    {
        final RemoveObservationRequestData request = RemoveObservationRequestData.parseFrom(obsMessage.getData());
            
        //pull out the type of interaction
        final Query requestQuery = Query.parseFrom(request.getObsQuery().toByteString());
        
        final ObservationQuery obsQuery = createObservationQuery(requestQuery);
        
        final long obsRemoved = obsQuery.remove();
        
        final RemoveObservationResponseData response = 
                RemoveObservationResponseData.newBuilder().setNumberOfObsRemoved(obsRemoved).build();
        
        m_MessageFactory.createObservationStoreResponseMessage(message,
              ObservationStoreMessageType.RemoveObservationResponse, response).queue(channel);
    
        return request;
    }

    /**
     * Handle the request to delete an observation or observations by UUID. 
     * @param message
     *     message that contains the request parameters to use to query the observation store
     * @param obsMessage
     *     message containing the observation store namespace message
     * @param channel
     *     the channel from which the message originated from
     * @return
     *     the parsed data message
     * @throws InvalidProtocolBufferException 
     *     throw in the event that the namespace specific message could not be parsed
     */
    private Message removeObservationByUUID(final TerraHarvestMessage message, 
        final ObservationStoreNamespace obsMessage, final RemoteChannel channel) throws InvalidProtocolBufferException 
    {
        //request to remove by UUID
        final RemoveObservationByUUIDRequestData request = RemoveObservationByUUIDRequestData.
            parseFrom(obsMessage.getData());

        //process request, by removing all requested observations
        for (UUID uuid : request.getUuidOfObservationList())
        {
            m_ObservationStore.remove(SharedMessageUtils.convertProtoUUIDtoUUID(uuid));
        }

        //send response
        m_MessageFactory.createObservationStoreResponseMessage(message, 
            ObservationStoreMessageType.RemoveObservationByUUIDResponse, null).queue(channel);

        //return request for the event
        return request;
    }

    /**
     * Handle the request to find observations by UUID.
     * @param message
     *     message that contains the request parameters to use to query the observation store
     * @param obsMessage
     *     message containing the observation store namespace message
     * @param channel
     *     the channel from which the message originated from
     * @return
     *     the parsed data message
     * @throws InvalidProtocolBufferException
     *     throw in the event that the namespace specific message could not be parsed. 
     */
    private Message findObservation(final TerraHarvestMessage message, final ObservationStoreNamespace obsMessage,
        final RemoteChannel channel) throws InvalidProtocolBufferException 
    {
        final FindObservationByUUIDRequestData request = 
                FindObservationByUUIDRequestData.parseFrom(obsMessage.getData());
        if (request.getObservationFormat() != RemoteTypesGen.LexiconFormat.Enum.NATIVE)
        {
            throw new UnsupportedOperationException(
               String.format("Lexicon format %s is not valid for observation by UUID", request.getObservationFormat()));
        }

        //convert proto uuids to java uuid
        final List<java.util.UUID> javaUuids = new ArrayList<java.util.UUID>();
        for (UUID uuid : request.getUuidOfObservationList())
        {
            javaUuids.add(SharedMessageUtils.convertProtoUUIDtoUUID(uuid));
        }

        //get observations
        final List<Observation> observations = new ArrayList<Observation>(); 
        for (java.util.UUID uuid : javaUuids)
        {
            //fetch uuid
            final Observation obs = m_ObservationStore.find(uuid);

            //obs could be null if not found
            if (obs != null)
            {
                observations.add(obs);
            }
        }

        //convert the observations
        final List<ObservationGen.Observation> protoObservations = createProtoObservationList(observations);

        //response message
        final FindObservationByUUIDResponseData response = FindObservationByUUIDResponseData.newBuilder().
            addAllObservationNative(protoObservations).build();

        //send response
        m_MessageFactory.createObservationStoreResponseMessage(message, 
            ObservationStoreMessageType.FindObservationByUUIDResponse, response).queue(channel);

        //return request for event
        return request;
    }

    /**
     * Create a list of proto observations from a list of {@link Observation}.
     * @param observations
     *     a collection of observations
     * @return
     *     list of converted observations
     */
    private List<ObservationGen.Observation> createProtoObservationList(final Collection<Observation> observations)
    {
        //List to return
        final List<ObservationGen.Observation> protoObs = new ArrayList<ObservationGen.Observation>();
        for (Observation observ : observations)
        {
            try
            {
                final ObservationGen.Observation protoObsGen = (ObservationGen.Observation)m_Converter.
                    convertToProto(observ);
                protoObs.add(protoObsGen);
            }
            catch (final ObjectConverterException exception)
            {
                m_Logging.error(exception, "Unable to convert a remotely requested observation with UUID %s to a "
                    + "protocol buffer equivalent.", observ.getUuid());
            }
        }
        
        //return list
        return protoObs;
    }
    
    /**
     * Create a {@link ObservationQuery} from the given {@link Query} message.
     * @param queryRequest
     *  the message that contains the query parameters
     * @return
     *  the {@link ObservationQuery} object that was generated from the given {@link Query}
     * @throws IllegalArgumentException
     *  if the given observation sub type or sort order values given are not within the 
     *  range of acceptable values
     * @throws IllegalStateException
     *  if the asset uuid and asset type are both set
     */
    private ObservationQuery createObservationQuery(final Query queryRequest) throws IllegalArgumentException, // NOCHECKSTYLE: This logic is required until refactoring can be done
            IllegalStateException
    {
        final ObservationQuery obsQuery = m_ObservationStore.newQuery();
        
        if (queryRequest.hasMaxNumberOfObs())
        {
            obsQuery.withMaxObservations(queryRequest.getMaxNumberOfObs());
        }
        
        if (queryRequest.hasAssetUuid())
        {
            obsQuery.withAssetUuid(SharedMessageUtils.convertProtoUUIDtoUUID(queryRequest.getAssetUuid()));
        }
        
        if (queryRequest.hasAssetType())
        {
            obsQuery.withAssetType(queryRequest.getAssetType());
        }
        
        for (ObservationSubType.Enum subTypeProto : queryRequest.getObservationSubTypeList())
        {
            final ObservationSubTypeEnum subType = ObservationSubTypeEnumConverter.convertProtoEnumToJava(subTypeProto);
            
            obsQuery.withSubType(subType);
        }
        
        if (queryRequest.hasCreatedTimeRange())
        {
            final TimeConstraintData times = queryRequest.getCreatedTimeRange();
            obsQuery.withTimeCreatedRange(new Date(times.getStartTime()), new Date(times.getStopTime()));
        }
        
        if (queryRequest.hasObservedTimeRange())
        {
            final TimeConstraintData times = queryRequest.getObservedTimeRange();
            obsQuery.withTimeObservedRange(new Date(times.getStartTime()), new Date(times.getStopTime()));
        }
        
        if (queryRequest.hasRange())
        {
            final Range range = queryRequest.getRange();
            obsQuery.withRange(range.getFromInclusive(), range.getToExclusive());
        }
        
        if (queryRequest.hasSortField() && queryRequest.hasSortOrder())
        {
            obsQuery.withOrder(EnumConverter.convertProtoSortFieldToJava(queryRequest.getSortField()),
                               EnumConverter.convertProtoSortOrderToJava(queryRequest.getSortOrder()));
        }
        
        return obsQuery;
    }
}
